//problem No. 2573, 빙산
#include <iostream>
#include <vector>
#include <list>
#include <queue>
using namespace std;

struct IJ { int i, j, cnt; };

list<IJ> ice;
int map[300][300], visited[300][300];
int di[] = { 0, 0, 1, -1 };
int dj[] = { 1, -1, 0, 0 };
int N, M, iceCnt;

int main() {
	cin >> N >> M;
	for (int i = 0; i < N; i++)
		for (int j = 0; j < M; j++) {
			cin >> map[i][j];
			if (map[i][j])
				ice.push_back({ i, j, 0 });
		}

	int year = 0;
	while(1) {
		++year;

		//얼음이 녹는 양 계산
		for (auto& e : ice) {
			e.cnt = 0;

			for (int d = 0; d < 4; d++) {
				int ni = e.i + di[d];
				int nj = e.j + dj[d];
				if (map[ni][nj] == 0)
					e.cnt++;
			}
		}

		//얼음을 녹임
		for (auto it = ice.begin(); it != ice.end(); it++) {
			int i = it->i, j = it->j;
			map[i][j] -= it->cnt;
			if (map[i][j] <= 0) {
				map[i][j] = 0;
				it = ice.erase(it);
			}

			//얼음이 모두 녹았으므로 0 출력
			if (ice.empty()) {
				cout << 0;
				exit(0);
			}
		}

		//빙산 수 세기 전 방문배열 초기화
		for (auto& e : ice)
			visited[e.i][e.j] = 0;
		
		//빙산 수 세기(use bfs)
		iceCnt = 0;
		for (auto& e : ice) {
			if (!visited[e.i][e.j]) {
				iceCnt++;
				//빙산이 분리됐으므로 답 출력
				if (iceCnt > 1) {
					cout << year;
					exit(0);
				}

				queue<IJ> q;
				q.push(e);
				visited[e.i][e.j] = 1;
				while (!q.empty()) {
					IJ ce = q.front(); q.pop();

					for (int d = 0; d < 4; d++) {
						int ni = ce.i + di[d];
						int nj = ce.j + dj[d];
						if (!visited[ni][nj] && map[ni][nj] > 0) {
							q.push({ ni, nj, 0 });
							visited[ni][nj] = 1;
						}
					}
				}
			}
		}
	}

	cout << 0;
}